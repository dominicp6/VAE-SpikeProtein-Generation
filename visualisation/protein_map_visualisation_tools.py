import os
import umap.umap_ as umap  # make sure that you install "umap-learn" not "umap"
import matplotlib.pyplot as plt
from amino_acid_encoding import ProteinSequenceEncoder
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA


def encode_sequences(infile, encoding_type, data_directory=None, encodings_directory=None, mask=None):
    """
    Encodes aligned sequences from a fasta file.

    Valid encoding types are:
    'One_hot', 'One_hot_6_bit', 'Binary_5_bit', 'Hydrophobicity_matrix', 'Meiler_parameters', 'Acthely_factors',
    'PAM250', 'BLOSUM62', 'Miyazawa_energies', 'Micheletti_potentials', 'AESNN3', 'ANN4D', 'ProtVec'

    Note:
    If a mask is required, then it should be generated by running the get_epitope_mask function from epitope_mask.py

    :param infile: the fasta file of aligned sequences.
    :param encoding_type: which type of position-independent encoding to use.
    :param mask: an epitope mask to apply to the encoding (optional).
    :return:
    frequencies       - the number of times that each sequence appeared (used during visualisation)
    encoded_sequences - the encoded amino acid sequences
    """
    encoder = ProteinSequenceEncoder(encoding_type=encoding_type,
                                     data_directory=data_directory,
                                     encodings_directory=encodings_directory,
                                     mask=mask)

    frequencies, encoded_sequences = encoder.encode_from_fasta_file(infile, f'1_in_500_encoded_{encoding_type}.txt')
    return frequencies, encoded_sequences


def embed_with_PCA(encoded_sequences):
    """
    Embeds a list of encoded sequences down to two dimensions using PCA.
    """
    reducer = PCA(n_components=2)
    sequence_embeddings = reducer.fit_transform(encoded_sequences)
    explained_variance = reducer.explained_variance_ratio_
    return sequence_embeddings, explained_variance


def embed_with_tSNE(encoded_sequences, PCA_dimension=50):
    """
    Embeds a list of encoded sequences down to two dimensions using tSNE.

    :param encoded_sequences: The sequences to embed.
    :param PCA_dimension: The dimensionality of the intermediary PCA dimensionality reduction (required to be approx.
                          less than or equal to 50 for an accurate tSNE embedding).
    """
    pca = PCA(n_components=PCA_dimension)
    pca_reduced_embeddings = pca.fit_transform(encoded_sequences)
    reducer = TSNE(init='pca')
    sequence_embeddings = reducer.fit_transform(pca_reduced_embeddings)
    return sequence_embeddings


def embed_with_UMAP(encoded_sequences, metric, seed):
    """
    Embeds a list of encoded sequences down to two dimensions using UMAP.

    :param encoded_sequences: The sequences to embed.
    :param metric: The distance metric to be used by UMAP (e.g. 'cosine' or 'euclidean')
    :param seed: The random seed to be used by UMAP.
    :return:
    """
    reducer = umap.UMAP(metric=metric, random_state=seed)
    sequence_embeddings = reducer.fit_transform(encoded_sequences)
    return sequence_embeddings


def plot_2D_embedding_map(embeddings, frequencies, labels=None, markerSize=5, method='PCA'):
    """
    Plots a 2D map from a list of embeddings and their associated sequence frequency.

    :param labels: annotations to add to the figure
    :param markerSize: relative point markerSize
    :param method: the dimensionality reduction method.
    """
    assert method == 'PCA' or method == 'UMAP' or method == 'tSNE', "method must be either PCA, UMAP or tSNE"
    marker_sizes = [frequency * markerSize for frequency in frequencies]

    # plot
    plt.scatter(embeddings[:, 0],
                embeddings[:, 1],
                s=marker_sizes, alpha=0.25)
    plt.gca().set_aspect('equal', 'datalim')
    plt.gcf().set_size_inches(12, 12)
    plt.title('2D embeddings of SARS-COV19 spike proteins', fontsize=20)
    if labels is not None:
        plt.gca().text(0.95, 0.95, '\n'.join(labels), horizontalalignment='right', verticalalignment='top',
                       transform=plt.gca().transAxes)

    # axes labels
    if method == 'PCA':
        plt.xlabel('PCA 1')
        plt.ylabel('PCA 2')
    elif method == 'tSNE':
        plt.xlabel('tSNE 1')
        plt.ylabel('tSNE 2')
    elif method == 'UMAP':
        plt.xlabel('UMAP 1')
        plt.ylabel('UMAP 2')

    plt.show()


def generate_embedding_map_from_database(aligned_fasta_file,
                                         encoding_type='PAM250',
                                         UMAP_metric='cosine',
                                         seed=42,
                                         markerSize=1,
                                         method='PCA',
                                         data_directory=os.path.join("..", "data", "spike_protein_sequences"),
                                         encodings_directory=os.path.join("..", "data", "encodings"),
                                         mask=None):
    """
    Plots a 2D representation of the dimensionality-reduced embeddings of the encoded sequences in a fasta database.

    :param aligned_fasta_file: a database of aligned fasta sequences.
    :param encoding_type: the type of amino acid encoding to use in the visualisation.
    :param UMAP_metric: (needed if method == 'UMAP')
    :param seed:        (needed if method == 'UMAP')
    :param markerSize:  relative point markerSize.
    :param method:      The dimensionality reduction method to use (one of 'PCA', 'tSNE', 'UMAP').
    :param mask:        An epitope mask to be applied to the encoded sequences (optional).
    :return:
    """

    assert method == 'PCA' or method == 'UMAP' or method == 'tSNE', "method must be either PCA, UMAP or tSNE"

    # encoded the protein sequences
    frequencies, encoded_sequences = encode_sequences(infile=aligned_fasta_file,
                                                      encoding_type=encoding_type,
                                                      mask=mask,
                                                      data_directory=data_directory,
                                                      encodings_directory=encodings_directory)

    # compute the sequence embeddings
    if method == 'PCA':
        sequence_embeddings, explained_variance = embed_with_PCA(encoded_sequences)
        labels = ['PCA', encoding_type, ', '.join([str(var) for var in explained_variance])]
    elif method == 'tSNE':
        sequence_embeddings = embed_with_tSNE(encoded_sequences)
        labels = ['tSNE', encoding_type]
    elif method == 'UMAP':
        sequence_embeddings = embed_with_UMAP(encoded_sequences, metric=UMAP_metric, seed=seed)
        labels = ['UMAP', encoding_type, UMAP_metric, f'seed: {seed}']
    else:
        raise Exception('Invalid method. Must be PCA, tSNE or UMAP.')

    # plot the result
    plot_2D_embedding_map(sequence_embeddings, frequencies, markerSize=markerSize, labels=labels, method=method)
